<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v3.min.js"></script>

  <style>
    .gridlines line {
      stroke: #bbb;
    }

    .gridlines .domain {
      stroke: none;
    }

    .neighborhood {
      fill: #eee;
      stroke: #fff;
      stroke-width: 2;
    }
  </style>
  <title>INFO 4310 - A1</title>
</head>


<body>
  <h1>INFO 4310 - Homework 1</h1>
  <h3>Student: Longyi Zhang (lz533)</h3>

  <div>
    <svg id="main" height=900 width=900 style="border:1px solid black;margin-bottom: 50px;">
    </svg>

    <svg id="aux" height=600 width=800 style="border:3px solid purple;margin-bottom: 50px;">
    </svg>
    <script>

      // set up map vis
      const main = d3.select("#main")
      const mainMargin = { t: 20, r: 20, b: 20, l: 20 }
      const mainWidth = main.attr("width") - mainMargin.l - mainMargin.r
      const mainHeight = main.attr("height") - mainMargin.t - mainMargin.b
      const viewport = main.append("g")
        .attr("transform", `translate(${mainMargin.l},${mainMargin.t})`)

      // set up auxiliary vis
      const aux = d3.select("#aux")
      const auxMargin = { t: 20, r: 20, b: 20, l: 20 }
      const auxWidth = aux.attr("width") - auxMargin.l - auxMargin.r
      const auxHeight = aux.attr("height") - auxMargin.t - auxMargin.b
      const plot = aux.append("g")
        .attr("transform", `translate(${auxMargin.l},${auxMargin.t})`)


      let render = async function () {
        let df = await d3.csv('Street_Tree_List-2022-01-30_ULTRAFILTERED.csv')
        // let raw = await d3.csv('Street_Tree_List-2022-01-30_RAW.csv')
        let sf = await d3.json("SF-Neighborhoods.geo.json")

        console.log(df)

        // map scaffolding
        let neighborhoods = topojson.feature(sf, sf.objects.SFNeighborhoods)
        let projection = d3.geoAlbersUsa().fitSize([mainWidth, mainHeight], neighborhoods)
        let path = d3.geoPath().projection(projection)
        main.selectAll("path.neighborhood").data(neighborhoods.features).join("path")
          .attr("class", "neighborhood")
          .attr("d", path)

        // preprocessing of loaded tree dataset for visualisation, in addition to preprocessing to the .csv files
        df.forEach(d => {
          d.Position = projection([d.Longitude, d.Latitude])
        })
        // sum up tree characteristics by species
        let bySpecies = Array.from(d3.group(df, d => d.qSpecies))
        bySpecies.forEach(d => {
          d[2] = d[1].length
        })
        bySpecies.sort((a, b) => { return -a[2] - -b[2] })
        console.log((bySpecies))



        // draw trees
        main.selectAll("circle").data(df)
          .join("circle")
          .attr("cx", d => d.Position[0])
          .attr("cy", d => d.Position[1])
          .attr("r", 1)
          .attr("fill", "forestgreen")
          .attr("opacity", 0.4)

      }
      render()




        //     let chartArea = svg.append('g') // append a <g> tag
        //       .attr('transform', `translate(${margins.left},${margins.top})`);
        //     const chartWidth = width - margins.left - margins.right;
        //     const chartHeight = height - margins.top - margins.bottom;
        //     // console.log(chartWidth);
        //     // console.log(chartHeight)

        //     data.forEach((d, i) => {
        //       d['day'] = Number(d['Release Day']);
        //       d['trans'] = Number(d['Transistors(million)']);
        //     })

        //     //scale setup
        //     const dayExtent = d3.extent(data, d => d['day']);
        //     const transExtent = d3.extent(data, d => d['trans']);
        //     const xScale = d3.scaleLinear().domain(dayExtent).range([0, chartWidth]);
        //     // const yScale = d3.scaleLinear()
        //     const yScale = d3.scaleLog()
        //       .domain(transExtent)
        //       .range([chartHeight, 0]); //inverse y-range

        //     //c. axes & gridlines
        //     let leftAxis = d3.axisLeft(yScale);
        //     svg.append('g')
        //       .attr('transform', `translate(${margins.left - 10},${margins.top})`)
        //       .call(leftAxis);

        //     let leftGridlines = d3.axisLeft(yScale)
        //       .tickSize(-chartWidth - 10)
        //       .tickFormat('');
        //     svg.append('g')
        //       .attr('class', 'gridlines')
        //       .attr('transform', `translate(${margins.left - 10},${margins.top})`)
        //       .call(leftGridlines);

        //     let bottomAxis = d3.axisBottom(xScale);
        //     svg.append('g')
        //       .attr('transform', `translate(${margins.left},${chartHeight + margins.top + 10})`)
        //       .call(bottomAxis);

        //     let bottomGridlines = d3.axisBottom(xScale)
        //       .tickSize(-chartHeight - 10)
        //       .tickFormat('');
        //     svg.append('g')
        //       .attr('class', 'gridlines')
        //       .attr('class', 'var')
        //       .attr('transform', `translate(${margins.left},${margins.top + chartHeight + 10})`)
        //       .call(bottomGridlines);

        //     // d. drawing circles
        //     data.forEach((d, i) => {
        //       chartArea.append('circle')
        //         .attr('cx', xScale(d['day']))
        //         .attr('cy', yScale(d['trans']))
        //         .attr('r', 3)
        //         .style('fill', '#00004C')
        //         .attr('opacity', 0.3)

        //       // e. logarithmic transformation




        //     });

        //   }
        // )

    </script>
  </div>

</body>

</html>